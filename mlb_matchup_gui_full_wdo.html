<!--
MLB Matchup GUI
===============

This standalone HTML page implements a graphical interface for comparing
Major League Baseball hitters and pitchers.  All data are fetched from
MLB’s public Stats API at runtime.  There is no server component – you
can open this file directly in a web browser and it will populate the
drop‑down lists with all active players, look up head‑to‑head stats,
retrieve career slash lines, and adjust results based on ballpark
dimensions and environmental conditions.

The environmental adjustment model is based on published research
showing that colder air reduces fly‑ball distance by roughly 16 ft
when temperatures drop from 90 °F to 50 °F【627969437292740†L26-L31】 and that thin air at
Denver’s Coors Field (5,280 ft elevation) can increase carry by
around 10 %【779714290220229†L74-L78】.  See mlb_matchup_tool.py for the Python version.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MLB Matchup Comparison</title>
  <!-- Load Plotly for interactive charts -->
  <script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
  <style>
    /* Modern, responsive layout that fills the viewport. */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #f0f2f5;
    }
    .container {
      /* Stretch across the full viewport with a margin for breathing room. */
      width: 100%;
      max-width: 1200px;
      margin: 1rem auto;
      background: #ffffff;
      padding: 2rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      border-radius: 8px;
      min-height: calc(100vh - 2rem);
      display: flex;
      flex-direction: column;
    }
    h1 {
      margin-top: 0;
      font-size: 2rem;
      text-align: center;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
    }
    label {
      font-weight: bold;
      margin-bottom: 0.25rem;
    }
    select, input {
      width: 100%;
      padding: 0.5rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }
    button {
      margin-top: 1rem;
      align-self: start;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      color: #fff;
      background-color: #007bff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    button:hover {
      background-color: #0056b3;
    }
    #results {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      flex-grow: 1;
      overflow-y: auto;
      /* Use a responsive grid to organise summary and charts nicely */
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 1rem;
    }
    /* Summary text spans across all columns */
    #summaryText {
      grid-column: 1 / -1;
    }
    /* Chart containers inside results */
    .chart-container {
      width: 100%;
      height: 350px;
    }
    #results h2 {
      margin-top: 0;
    }
    @media (max-width: 600px) {
      .container {
        padding: 1rem;
      }
      h1 {
        font-size: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <!-- Tab buttons -->
  <div id="tabButtons" style="display:flex; gap:1rem; margin: 1rem;">
    <button id="matchTab" style="padding:0.5rem 1rem;">Matchup Analysis</button>
    <button id="todayTab" style="padding:0.5rem 1rem;">Today's Projections</button>
  </div>
  <!-- Matchup section -->
  <div id="matchSection" class="container" style="display:block;">
    <h1>MLB Matchup Comparison</h1>
    <p>Select a batter, pitcher and ballpark.  Set the weather if known and click <strong>Compare</strong> to evaluate the matchup.</p>
    <div class="grid">
      <div>
        <label for="batterSelect">Batter:</label>
        <select id="batterSelect"></select>
      </div>
      <div>
        <label for="pitcherSelect">Pitcher:</label>
        <select id="pitcherSelect"></select>
      </div>
      <div>
        <label for="stadiumSelect">Ballpark:</label>
        <select id="stadiumSelect"></select>
      </div>
      <div>
        <label for="temperatureInput">Temperature (°F):</label>
        <input id="temperatureInput" type="number" placeholder="70" value="70">
      </div>
      <div>
        <label for="windSpeedInput">Wind speed (mph):</label>
        <input id="windSpeedInput" type="number" placeholder="0" value="0">
      </div>
      <div>
        <label for="windDirSelect">Wind direction:</label>
        <select id="windDirSelect">
          <option value="none" selected>none/crosswind</option>
          <option value="out">out (toward outfield)</option>
          <option value="in">in (toward home)</option>
        </select>
      </div>
    </div>
    <button id="compareBtn">Compare</button>
    <div id="results">
      <div id="summaryText"></div>
      <div id="opsChart" class="chart-container"></div>
      <div id="parkEnvChart" class="chart-container"></div>
      <div id="summary3D" class="chart-container"></div>
      <div id="eventChart" class="chart-container"></div>
    </div>
  </div>
  <!-- Today's projections section -->
  <div id="todaySection" class="container" style="display:none;">
    <h1>Today's Hit Projections</h1>
    <p>Select "Load Projections" to fetch today's games and display the players most likely to hit singles, doubles, triples and home runs based on the weather at each park.</p>
    <button id="loadProjectionsBtn">Load Projections</button>
    <div id="todayStatus" style="margin-top:1rem; font-weight:bold;"></div>
    <div id="todayResults" style="margin-top:1rem;"></div>
  </div>

  <script>
    // Ballpark dimensions and altitudes – mirror the Python constants.  Only
    // Coors Field and a few other parks have notable elevations.  These
    // distances come from Ballparks of Baseball’s comparison table【720097225716978†L119-L134】.
    const STADIUM_DIMENSIONS = {
      "American Family Field": [332, 400, 325],
      "Angel Stadium": [330, 396, 330],
      "Busch Stadium": [336, 400, 335],
      "Camden Yards": [337, 406, 320],
      "Chase Field": [330, 407, 335],
      "Citi Field": [335, 405, 330],
      "Citizens Bank Park": [330, 401, 329],
      "Comerica Park": [345, 420, 330],
      "Coors Field": [347, 415, 350],
      "Dodger Stadium": [330, 400, 300],
      "Fenway Park": [310, 420, 302],
      "Globe Life Field": [329, 407, 326],
      "Great American Ball Park": [328, 404, 325],
      "Guaranteed Rate Field": [330, 400, 335],
      "Kauffman Stadium": [330, 400, 330],
      "loanDepot Park": [340, 420, 335],
      "Minute Maid Park": [315, 435, 326],
      "Nationals Park": [336, 403, 335],
      "Oracle Park": [339, 399, 309],
      "Petco Park": [336, 396, 322],
      "PNC Park": [325, 399, 320],
      "Progressive Field": [325, 405, 325],
      "Rogers Centre": [328, 400, 328],
      "Steinbrenner Field": [318, 408, 314],
      "Sutter Health Park": [330, 403, 325],
      "T-Mobile Park": [331, 405, 327],
      "Target Field": [339, 404, 328],
      "Truist Park": [335, 400, 325],
      "Wrigley Field": [355, 400, 353],
      "Yankee Stadium": [318, 404, 314]
    };
    const STADIUM_ALTITUDE = {
      "Coors Field": 5280,
      "Chase Field": 1080,
      "Globe Life Field": 560,
      "Minute Maid Park": 80,
      "Dodger Stadium": 345,
      "Angel Stadium": 160,
      "Truist Park": 1050
    };

    // Geographic coordinates for each ballpark.  These approximate values are
    // derived from widely available sources such as ballpark summaries and
    // location data (e.g., Wikipedia).  They allow the app to query a
    // weather API for current conditions when a park is selected.  For
    // example, American Family Field is located at 43.02833° N, 87.97111° W【376216865034632†L149-L190】.
    const STADIUM_COORDS = {
      "American Family Field": { lat: 43.02833, lon: -87.97111 },
      "Angel Stadium": { lat: 33.80036, lon: -117.88299 },
      "Busch Stadium": { lat: 38.6226, lon: -90.1930 },
      "Camden Yards": { lat: 39.2839, lon: -76.6228 },
      "Chase Field": { lat: 33.4455, lon: -112.0669 },
      "Citi Field": { lat: 40.7571, lon: -73.8458 },
      "Citizens Bank Park": { lat: 39.9058, lon: -75.1665 },
      "Comerica Park": { lat: 42.3390, lon: -83.0480 },
      "Coors Field": { lat: 39.7559, lon: -104.9941 },
      "Dodger Stadium": { lat: 34.0739, lon: -118.2390 },
      "Fenway Park": { lat: 42.3467, lon: -71.0972 },
      "Globe Life Field": { lat: 32.7473, lon: -97.0842 },
      "Great American Ball Park": { lat: 39.0976, lon: -84.5080 },
      "Guaranteed Rate Field": { lat: 41.8300, lon: -87.6339 },
      "Kauffman Stadium": { lat: 39.0516, lon: -94.4803 },
      "loanDepot Park": { lat: 25.7783, lon: -80.2197 },
      "Minute Maid Park": { lat: 29.7573, lon: -95.3555 },
      "Nationals Park": { lat: 38.8729, lon: -77.0074 },
      "Oracle Park": { lat: 37.7786, lon: -122.3893 },
      "Petco Park": { lat: 32.7073, lon: -117.1569 },
      "PNC Park": { lat: 40.4469, lon: -80.0057 },
      "Progressive Field": { lat: 41.4958, lon: -81.6853 },
      "Rogers Centre": { lat: 43.6415, lon: -79.3894 },
      "Steinbrenner Field": { lat: 27.9759, lon: -82.4715 },
      "Sutter Health Park": { lat: 38.5807, lon: -121.5139 },
      "T-Mobile Park": { lat: 47.5914, lon: -122.3325 },
      "Target Field": { lat: 44.9817, lon: -93.2775 },
      "Truist Park": { lat: 33.8908, lon: -84.4679 },
      "Wrigley Field": { lat: 41.9484, lon: -87.6553 },
      "Yankee Stadium": { lat: 40.8299, lon: -73.9262 }
    };

    // Precompute the average outfield distance across all parks.  We use
    // this baseline to classify ballparks as hitter‑ or pitcher‑friendly.
    const GLOBAL_AVG_DIST = (() => {
      let total = 0;
      let count = 0;
      Object.values(STADIUM_DIMENSIONS).forEach(d => {
        total += d[0] + d[1] + d[2];
        count += 3;
      });
      return total / count;
    })();

    // Global lists of players; will be populated on load
    let batters = [];
    let pitchers = [];

    async function fetchActivePlayers() {
      const url = 'https://statsapi.mlb.com/api/v1/sports/1/players?season=2025&gameType=R&activeStatus=Y';
      const resp = await fetch(url);
      const data = await resp.json();
      const players = data.people;
      // Partition into pitchers and non‑pitchers
      players.forEach(p => {
        const pos = p.primaryPosition && p.primaryPosition.abbreviation;
        const entry = { id: p.id, name: p.fullName };
        if (pos === 'P' || pos === 'TWP') {
          pitchers.push(entry);
        } else {
          batters.push(entry);
        }
      });
      // Sort alphabetically
      batters.sort((a, b) => a.name.localeCompare(b.name));
      pitchers.sort((a, b) => a.name.localeCompare(b.name));
    }

    function populateSelect(select, options) {
      options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.id;
        option.textContent = opt.name;
        select.appendChild(option);
      });
    }

    function populateStadiums() {
      const select = document.getElementById('stadiumSelect');
      Object.keys(STADIUM_DIMENSIONS).sort().forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
      });
    }

    function computeEnvironmentFactor(temp, windSpeed, windDir, altitude) {
      const tempDelta = temp - 70.0;
      let tempFactor = 1.0 + 0.001 * tempDelta;
      let windFactor = 1.0;
      if (windDir === 'out') {
        windFactor += 0.001 * windSpeed;
      } else if (windDir === 'in') {
        windFactor -= 0.001 * windSpeed;
      }
      const altFactor = 1.0 + 0.02 * (altitude / 1000.0);
      return tempFactor * windFactor * altFactor;
    }

    async function getCareerStats(playerId, group) {
      const url = `https://statsapi.mlb.com/api/v1/people/${playerId}/stats?stats=career&group=${group}`;
      const resp = await fetch(url);
      const data = await resp.json();
      const stats = data.stats && data.stats[0] && data.stats[0].splits;
      if (!stats || !stats.length) return { avg: 'NA', obp: 'NA', slg: 'NA', ops: 'NA' };
      const s = stats[0].stat;
      return { avg: s.avg || 'NA', obp: s.obp || 'NA', slg: s.slg || 'NA', ops: s.ops || 'NA' };
    }

    /**
     * Retrieve basic counting stats (hits, doubles, triples, home runs and at‑bats)
     * for a hitter’s career.  This endpoint is the same as getCareerStats but
     * returns raw totals used to build a distribution of hit types.
     */
    async function getCareerCounts(playerId) {
      const url = `https://statsapi.mlb.com/api/v1/people/${playerId}/stats?stats=career&group=hitting`;
      const resp = await fetch(url);
      const data = await resp.json();
      const splits = data.stats && data.stats[0] && data.stats[0].splits || [];
      if (!splits.length) return { hits: 0, doubles: 0, triples: 0, homeRuns: 0, atBats: 0 };
      const stat = splits[0].stat;
      return {
        hits: parseInt(stat.hits || 0),
        doubles: parseInt(stat.doubles || 0),
        triples: parseInt(stat.triples || 0),
        homeRuns: parseInt(stat.homeRuns || 0),
        atBats: parseInt(stat.atBats || 0)
      };
    }

    async function getHeadToHeadStats(batterId, pitcherId) {
      const url = `https://statsapi.mlb.com/api/v1/people/${batterId}/stats?stats=vsPlayer&opposingPlayerId=${pitcherId}&group=hitting`;
      const resp = await fetch(url);
      const data = await resp.json();
      const splits = data.stats && data.stats[0] && data.stats[0].splits || [];
      const agg = {
        atBats: 0,
        hits: 0,
        doubles: 0,
        triples: 0,
        homeRuns: 0,
        strikeOuts: 0,
        walks: 0,
        totalBases: 0
      };
      splits.forEach(entry => {
        const s = entry.stat;
        agg.atBats += parseInt(s.atBats || 0);
        agg.hits += parseInt(s.hits || 0);
        agg.doubles += parseInt(s.doubles || 0);
        agg.triples += parseInt(s.triples || 0);
        agg.homeRuns += parseInt(s.homeRuns || 0);
        agg.strikeOuts += parseInt(s.strikeOuts || 0);
        agg.walks += parseInt(s.baseOnBalls || 0);
        agg.totalBases += parseInt(s.totalBases || 0);
      });
      return agg;
    }

    function formatSlashLine(stats) {
      const { avg, obp, slg, ops } = stats;
      return `${avg}/${obp}/${slg}/${ops}`;
    }

    function formatFloat(num) {
      return Number.isFinite(num) ? num.toFixed(3) : 'NA';
    }

    /**
     * Fetch current weather at given coordinates and return an object
     * containing Fahrenheit temperature, wind speed in mph and a
     * direction category (out/in/none) analogous to the match‑up inputs.
     */
    async function getWeatherForCoords(lat, lon) {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&timezone=America/New_York`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) return null;
        const data = await resp.json();
        const cw = data.current_weather;
        if (!cw) return null;
        const tempF = cw.temperature * 9/5 + 32;
        const windMph = cw.windspeed * 0.621371;
        const deg = cw.winddirection;
        let category = 'none';
        if ((deg >= 315 || deg < 45)) {
          category = 'in';
        } else if (deg >= 135 && deg < 225) {
          category = 'out';
        } else {
          category = 'none';
        }
        return { tempF, windMph, category };
      } catch (e) {
        return null;
      }
    }

    /**
     * Load today's games and compute projection leaders for singles, doubles,
     * triples and home runs based on career stats and the weather at each
     * ballpark.  Results are displayed in the todayResults div.
     */
    async function loadTodayProjections() {
      const status = document.getElementById('todayStatus');
      const results = document.getElementById('todayResults');
      status.textContent = 'Fetching schedule…';
      results.textContent = '';
      // Determine today’s date in YYYY-MM-DD format using America/New_York
      const now = new Date();
      // convert to date string in local timezone (America/New_York) by adjusting offset
      const tzDate = now.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
      const scheduleUrl = `https://statsapi.mlb.com/api/v1/schedule?sportId=1&date=${tzDate}`;
      try {
        const schedResp = await fetch(scheduleUrl);
        const schedData = await schedResp.json();
        const games = schedData.dates && schedData.dates[0] && schedData.dates[0].games || [];
        if (!games.length) {
          status.textContent = 'No games scheduled for today.';
          return;
        }
        status.textContent = `Found ${games.length} games. Loading boxscores…`;
        // Holds players and their projections
        const players = [];
        // Iterate through games
        for (const game of games) {
          const gamePk = game.gamePk;
          const venueName = game.venue && game.venue.name;
          // Determine weather factors using stadium coords
          let weather = null;
          let dims = STADIUM_DIMENSIONS[venueName];
          const altitude = STADIUM_ALTITUDE[venueName] || 0;
          const coords = STADIUM_COORDS[venueName];
          if (coords) {
            weather = await getWeatherForCoords(coords.lat, coords.lon);
          }
          // If weather unavailable, skip environmental adjustment (use defaults)
          const tempF = weather ? weather.tempF : 70;
          const windMph = weather ? weather.windMph : 0;
          const windCat = weather ? weather.category : 'none';
          const envF = computeEnvironmentFactor(tempF, windMph, windCat, altitude);
          // Compute parkPercent for this venue
          let parkPercentLocal = null;
          if (dims) {
            const parkAvg = (dims[0] + dims[1] + dims[2]) / 3.0;
            parkPercentLocal = ((parkAvg - GLOBAL_AVG_DIST) / GLOBAL_AVG_DIST) * 100;
          }
          // Fetch boxscore to get players
          const boxUrl = `https://statsapi.mlb.com/api/v1/game/${gamePk}/boxscore`;
          const boxResp = await fetch(boxUrl);
          const boxData = await boxResp.json();
          const teamEntries = [boxData.teams.home, boxData.teams.away];
          for (const team of teamEntries) {
            const teamName = team.team.name;
            const playerObjs = team.players;
            for (const pid in playerObjs) {
              const p = playerObjs[pid];
              const person = p.person;
              const pos = p.position && p.position.abbreviation;
              // Skip pitchers and two‑way players as hitters unlikely
              if (!pos || pos === 'P') continue;
              // Build unique key to avoid duplicates across games if same player
              players.push({
                id: person.id,
                name: person.fullName,
                team: teamName,
                venue: venueName,
                envF,
                parkPercent: parkPercentLocal,
                dims,
                game: `${game.teams.away.team.name} @ ${game.teams.home.team.name}`
              });
            }
          }
        }
        status.textContent = `Computing projections for ${players.length} players…`;
        // Use a map to prevent duplicate players (same person may appear twice if doubleheader)
        const uniqueMap = new Map();
        players.forEach(pl => {
          if (!uniqueMap.has(pl.id)) {
            uniqueMap.set(pl.id, pl);
          }
        });
        const uniquePlayers = Array.from(uniqueMap.values());
        // For each unique player, fetch career counts and compute probabilities
        const projections = [];
        for (const pl of uniquePlayers) {
          const counts = await getCareerCounts(pl.id);
          const hits = counts.hits || 0;
          if (hits === 0) continue;
          const singles = Math.max(0, hits - counts.doubles - counts.triples - counts.homeRuns);
          let dist = {
            single: singles / hits,
            double: (counts.doubles || 0) / hits,
            triple: (counts.triples || 0) / hits,
            hr: (counts.homeRuns || 0) / hits
          };
          // Adjust for environment
          const extraKeys = ['double','triple','hr'];
          let sumEnv = dist.single;
          extraKeys.forEach(k => {
            dist[k] = dist[k] * pl.envF;
            sumEnv += dist[k];
          });
          dist.single = dist.single / sumEnv;
          extraKeys.forEach(k => {
            dist[k] = dist[k] / sumEnv;
          });
          // Adjust for park
          if (pl.parkPercent !== null && !isNaN(pl.parkPercent)) {
            const mult = 1 - (pl.parkPercent / 100);
            let sumPark = dist.single;
            extraKeys.forEach(k => {
              dist[k] = dist[k] * mult;
              sumPark += dist[k];
            });
            dist.single = dist.single / sumPark;
            extraKeys.forEach(k => {
              dist[k] = dist[k] / sumPark;
            });
          }
          projections.push({
            id: pl.id,
            name: pl.name,
            team: pl.team,
            venue: pl.venue,
            game: pl.game,
            probs: dist
          });
        }
        // Determine top players for each category
        const categories = ['single','double','triple','hr'];
        const leaders = {};
        categories.forEach(cat => {
          // Sort by probability desc and keep top 5
          const sorted = projections.slice().sort((a,b) => b.probs[cat] - a.probs[cat]);
          leaders[cat] = sorted.slice(0,5);
        });
        // Build HTML
        let html = '';
        categories.forEach(cat => {
          const title = cat.charAt(0).toUpperCase() + cat.slice(1);
          html += `<h3>${title} Leaders</h3>`;
          html += '<table style="width:100%; border-collapse: collapse; margin-bottom:1rem;">';
          html += '<thead><tr><th style="border-bottom:1px solid #ccc; text-align:left;">Player</th><th style="border-bottom:1px solid #ccc; text-align:left;">Team</th><th style="border-bottom:1px solid #ccc; text-align:left;">Game</th><th style="border-bottom:1px solid #ccc; text-align:right;">Probability</th></tr></thead><tbody>';
          leaders[cat].forEach(item => {
            html += `<tr><td>${item.name}</td><td>${item.team}</td><td>${item.game}</td><td style="text-align:right;">${(item.probs[cat]*100).toFixed(1)}%</td></tr>`;
          });
          html += '</tbody></table>';
        });
        status.textContent = '';
        results.innerHTML = html;
      } catch (err) {
        console.error(err);
        status.textContent = 'Error loading today’s projections.';
      }
    }

    /**
     * Fetch current weather for the selected ballpark and populate the
     * temperature and wind inputs.  Uses the open‑mete o API (no API key
     * required) to query by latitude and longitude.  Temperature is
     * converted from °C to °F and wind speed from km/h to mph.  Wind
     * direction degrees are categorised into "out", "in" or
     * crosswind depending on whether the wind blows toward the
     * outfield, toward home plate or sideways.  If the API call fails,
     * the inputs remain unchanged.
     */
    async function fetchWeatherForStadium(stadiumName) {
      const coords = STADIUM_COORDS[stadiumName];
      if (!coords) return;
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&current_weather=true&timezone=America/New_York`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) return;
        const data = await resp.json();
        const cw = data.current_weather;
        if (!cw) return;
        // Convert temperature from Celsius to Fahrenheit
        const tempF = cw.temperature * 9/5 + 32;
        // Convert windspeed from km/h to mph
        const windMph = cw.windspeed * 0.621371;
        // Determine wind direction category
        const deg = cw.winddirection;
        let category = 'none';
        if ((deg >= 315 || deg < 45)) {
          category = 'in';
        } else if (deg >= 135 && deg < 225) {
          category = 'out';
        } else {
          category = 'none';
        }
        // Populate the input fields
        document.getElementById('temperatureInput').value = Math.round(tempF);
        document.getElementById('windSpeedInput').value = Math.round(windMph);
        document.getElementById('windDirSelect').value = category;
      } catch (e) {
        // ignore errors silently
      }
    }

    /**
     * Determine relative advantages between batter and pitcher based on
     * career OPS, head‑to‑head OPS, ballpark dimensions and environmental
     * factors.  Returns an object with a narrative summary and a score.
     * A positive score favours the batter, a negative score favours the
     * pitcher, and zero indicates a neutral matchup.
     */
    function analyzeAdvantages(bCareer, pCareer, h2h, dims, envPercent) {
      // Convert OPS strings to numbers when possible.
      const parseOps = (opsStr) => {
        const num = parseFloat(opsStr);
        return Number.isFinite(num) ? num : NaN;
      };
      const bOps = parseOps(bCareer.ops);
      const pOps = parseOps(pCareer.ops);
      // Head‑to‑head OPS computed outside; if NaN, leave undefined.
      const h2hOps = h2h && h2h.atBats ? ((h2h.hits + h2h.walks) / (h2h.atBats + h2h.walks)) + (h2h.totalBases / h2h.atBats) : NaN;

      let score = 0;
      const reasons = [];

      // Compare batter’s career OPS to the pitcher’s career allowed OPS.
      if (Number.isFinite(bOps) && Number.isFinite(pOps)) {
        const diff = bOps - pOps;
        if (diff > 0.05) {
          score += 1;
          reasons.push(`The batter’s career OPS (${bOps.toFixed(3)}) is higher than the pitcher’s typical opponents’ OPS (${pOps.toFixed(3)})`);
        } else if (diff < -0.05) {
          score -= 1;
          reasons.push(`The pitcher generally suppresses hitters (OPS ${pOps.toFixed(3)}) better than the batter’s career average (${bOps.toFixed(3)})`);
        } else {
          reasons.push(`Both players’ career OPS values are similar (${bOps.toFixed(3)} vs ${pOps.toFixed(3)})`);
        }
      }

      // Compare head‑to‑head OPS to batter’s career OPS.
      if (Number.isFinite(h2hOps) && Number.isFinite(bOps)) {
        const diff2 = h2hOps - bOps;
        if (diff2 > 0.05) {
          score += 1;
          reasons.push(`Historically the batter has hit this pitcher better than average (head‑to‑head OPS ${h2hOps.toFixed(3)} vs career ${bOps.toFixed(3)})`);
        } else if (diff2 < -0.05) {
          score -= 1;
          reasons.push(`Head‑to‑head OPS (${h2hOps.toFixed(3)}) is below the batter’s career OPS (${bOps.toFixed(3)})`);
        } else {
          reasons.push(`Head‑to‑head performance (${formatFloat(h2hOps)}) is roughly in line with the batter’s career OPS`);
        }
      }

      // Ballpark friendliness
      if (dims) {
        const parkAvg = (dims[0] + dims[1] + dims[2]) / 3.0;
        const threshold = 5; // feet
        if (parkAvg < GLOBAL_AVG_DIST - threshold) {
          score += 1;
          reasons.push('This ballpark is shorter than average, favouring hitters');
        } else if (parkAvg > GLOBAL_AVG_DIST + threshold) {
          score -= 1;
          reasons.push('This ballpark’s deep fences favour pitchers');
        } else {
          reasons.push('The ballpark dimensions are about league average');
        }
      }

      // Environmental factors
      const envVal = parseFloat(envPercent);
      if (!isNaN(envVal)) {
        if (envVal > 0.5) {
          score += 1;
          reasons.push(`Warm temperature, tailwind or high altitude increase carry by ${envVal.toFixed(1)}%`);
        } else if (envVal < -0.5) {
          score -= 1;
          reasons.push(`Cool temperature, headwind or low altitude reduce carry by ${envVal.toFixed(1)}%`);
        } else {
          reasons.push(`Environmental effects (+${envVal.toFixed(1)}%) are minimal`);
        }
      }
      return { score, reasons };
    }

    async function compare() {
      const batterId = document.getElementById('batterSelect').value;
      const pitcherId = document.getElementById('pitcherSelect').value;
      const stadiumName = document.getElementById('stadiumSelect').value;
      const temp = parseFloat(document.getElementById('temperatureInput').value || '70');
      const windSpeed = parseFloat(document.getElementById('windSpeedInput').value || '0');
      const windDir = document.getElementById('windDirSelect').value;

      // Clear previous results
      const resultsDiv = document.getElementById('results');
      // Show loading message in the summary area only
      const summaryDiv = document.getElementById('summaryText');
      summaryDiv.textContent = 'Fetching statistics…';

      const [bCareer, pCareer, h2h] = await Promise.all([
        getCareerStats(batterId, 'hitting'),
        getCareerStats(pitcherId, 'pitching'),
        getHeadToHeadStats(batterId, pitcherId)
      ]);

      // Compute derived stats for the matchup
      const ba = h2h.atBats ? h2h.hits / h2h.atBats : NaN;
      const obpPa = h2h.atBats + h2h.walks;
      const obp = obpPa ? (h2h.hits + h2h.walks) / obpPa : NaN;
      const slg = h2h.atBats ? h2h.totalBases / h2h.atBats : NaN;
      const ops = obp + slg;

      const dims = STADIUM_DIMENSIONS[stadiumName];
      const altitude = STADIUM_ALTITUDE[stadiumName] || 0;
      const envFactor = computeEnvironmentFactor(temp, windSpeed, windDir, altitude);
      const envPercent = ((envFactor - 1.0) * 100).toFixed(1);
      // Compute park size deviation from league average once for reuse
      let parkPercent = null;
      if (dims) {
        const parkAvg = (dims[0] + dims[1] + dims[2]) / 3.0;
        parkPercent = ((parkAvg - GLOBAL_AVG_DIST) / GLOBAL_AVG_DIST) * 100;
      }

      // Derive an advantages summary based on several factors
      const advantage = analyzeAdvantages(bCareer, pCareer, h2h, dims, envPercent);

      // Fetch counting stats for the batter to build hit‑type distribution
      const careerCounts = await getCareerCounts(batterId);

      // Compute career hit type distribution
      const cHits = careerCounts.hits || 0;
      const cSingles = Math.max(0, cHits - (careerCounts.doubles || 0) - (careerCounts.triples || 0) - (careerCounts.homeRuns || 0));
      const cDist = { single: 0, double: 0, triple: 0, hr: 0 };
      if (cHits > 0) {
        cDist.single = cSingles / cHits;
        cDist.double = (careerCounts.doubles || 0) / cHits;
        cDist.triple = (careerCounts.triples || 0) / cHits;
        cDist.hr = (careerCounts.homeRuns || 0) / cHits;
      }
      // Compute head‑to‑head hit type distribution
      const hHits = h2h.hits || 0;
      const hSingles = Math.max(0, hHits - h2h.doubles - h2h.triples - h2h.homeRuns);
      const hDist = { single: 0, double: 0, triple: 0, hr: 0 };
      if (hHits > 0) {
        hDist.single = hSingles / hHits;
        hDist.double = h2h.doubles / hHits;
        hDist.triple = h2h.triples / hHits;
        hDist.hr = h2h.homeRuns / hHits;
      }
      // Weight head‑to‑head distribution by number of at‑bats, capped to emphasise
      const weightH2H = Math.min(h2h.atBats / 25.0, 1.0);
      const combinedDist = {};
      ['single', 'double', 'triple', 'hr'].forEach(key => {
        combinedDist[key] = (hDist[key] * weightH2H) + (cDist[key] * (1 - weightH2H));
      });
      // Adjust distribution by environmental factor (affects extra base hits)
      let envF = computeEnvironmentFactor(temp, windSpeed, windDir, altitude);
      // Only adjust extra‑base hits; singles scale remains 1
      let scaledDist = { ...combinedDist };
      const extraKeys = ['double', 'triple', 'hr'];
      let sumEnv = combinedDist.single;
      extraKeys.forEach(key => {
        scaledDist[key] = combinedDist[key] * envF;
        sumEnv += scaledDist[key];
      });
      // Normalise after environment scaling
      scaledDist.single = combinedDist.single / sumEnv;
      extraKeys.forEach(key => {
        scaledDist[key] = scaledDist[key] / sumEnv;
      });
      // Apply park factor: smaller parks increase extra base probabilities
      // Apply park factor: smaller parks increase extra base probabilities
      if (parkPercent !== null && !isNaN(parkPercent)) {
        const parkMult = 1 - (parkPercent / 100);
        // multiply extra base hits by parkMult
        let sumPark = scaledDist.single;
        extraKeys.forEach(key => {
          scaledDist[key] = scaledDist[key] * parkMult;
          sumPark += scaledDist[key];
        });
        // renormalise
        scaledDist.single = scaledDist.single / sumPark;
        extraKeys.forEach(key => {
          scaledDist[key] = scaledDist[key] / sumPark;
        });
      }
      // Compute expected total bases
      const expectedTB = 1 * scaledDist.single + 2 * scaledDist.double + 3 * scaledDist.triple + 4 * scaledDist.hr;
      // Determine clear pick: event type with highest probability
      let clearPick = 'single';
      let maxProb = scaledDist.single;
      ['double', 'triple', 'hr'].forEach(key => {
        if (scaledDist[key] > maxProb) {
          maxProb = scaledDist[key];
          clearPick = key;
        }
      });

      // Format results
      let output = '';
      output += `Hitter: ${document.getElementById('batterSelect').selectedOptions[0].text}\n`;
      output += `  Career slash line (AVG/OBP/SLG/OPS): ${formatSlashLine(bCareer)}\n`;
      output += `Pitcher: ${document.getElementById('pitcherSelect').selectedOptions[0].text}\n`;
      output += `  Career slash line against (AVG/OBP/SLG/OPS): ${formatSlashLine(pCareer)}\n\n`;

      if (h2h.atBats === 0) {
        output += 'No recorded plate appearances between these players.';
      } else {
        output += 'Head‑to‑Head Matchup:\n';
        output += `  At‑bats: ${h2h.atBats}\n`;
        output += `  Hits: ${h2h.hits} (2B: ${h2h.doubles}, 3B: ${h2h.triples}, HR: ${h2h.homeRuns})\n`;
        output += `  Walks: ${h2h.walks}, Strikeouts: ${h2h.strikeOuts}\n`;
        output += `  Slash line vs pitcher (AVG/OBP/SLG/OPS): ${formatFloat(ba)}/${formatFloat(obp)}/${formatFloat(slg)}/${formatFloat(ops)}\n`;
      }

      output += `\nBallpark: ${stadiumName}\n`;
      if (dims) {
        output += `  Dimensions (L‑C‑R): ${dims[0]}‑${dims[1]}‑${dims[2]} ft\n`;
      }
      if (altitude) {
        output += `  Altitude: ${altitude} ft\n`;
      }

      if (temp !== 70 || windSpeed !== 0 || altitude !== 0) {
        output += '\nEnvironmental factors:\n';
        output += `  Temperature: ${temp} °F\n`;
        if (windSpeed) {
          output += `  Wind: ${windSpeed} mph (${windDir})\n`;
        }
        if (altitude) {
          output += `  Altitude: ${altitude} ft\n`;
        }
        output += `  Estimated change in fly‑ball distance: ${envPercent}%\n`;
      }

      // Append advantages summary
      output += '\nMatchup analysis:\n';
      advantage.reasons.forEach(reason => {
        output += `  • ${reason}\n`;
      });
      // Interpret the overall score into a human‑readable summary
      let verdict;
      if (advantage.score >= 2) {
        verdict = 'strong advantage to the batter';
      } else if (advantage.score === 1) {
        verdict = 'slight advantage to the batter';
      } else if (advantage.score === 0) {
        verdict = 'neutral matchup';
      } else if (advantage.score === -1) {
        verdict = 'slight advantage to the pitcher';
      } else {
        verdict = 'strong advantage to the pitcher';
      }
      output += `\nOverall: ${verdict}.`;

      // Append predicted outcome distribution and clear pick
      output += `\n\nPredicted hit distribution (adjusted for weather and park):\n`;
      output += `  Single: ${(scaledDist.single * 100).toFixed(1)}%\n`;
      output += `  Double: ${(scaledDist.double * 100).toFixed(1)}%\n`;
      output += `  Triple: ${(scaledDist.triple * 100).toFixed(1)}%\n`;
      output += `  Home Run: ${(scaledDist.hr * 100).toFixed(1)}%\n`;
      output += `  Expected total bases: ${expectedTB.toFixed(2)}\n`;
      output += `\nClear pick: The batter is most likely to hit a ${clearPick}.`;
      // Render summary text as formatted preformatted block
      summaryDiv.innerHTML = `<pre style="white-space: pre-wrap; margin: 0;">${output}</pre>`;

      // Prepare numeric values for charts
      const parseOpsNum = (opsStr) => {
        const num = parseFloat(opsStr);
        return Number.isFinite(num) ? num : NaN;
      };
      const bOpsNum = parseOpsNum(bCareer.ops);
      const pOpsNum = parseOpsNum(pCareer.ops);
      const h2hOpsNum = h2h.atBats ? ((h2h.hits + h2h.walks) / (h2h.atBats + h2h.walks)) + (h2h.totalBases / h2h.atBats) : NaN;
      // Chart 1: OPS comparison
      const opsLabels = [];
      const opsValues = [];
      const opsColors = [];
      if (Number.isFinite(bOpsNum)) {
        opsLabels.push('Batter career OPS');
        opsValues.push(bOpsNum);
        opsColors.push('#007bff');
      }
      if (Number.isFinite(pOpsNum)) {
        opsLabels.push('Pitcher opponents OPS');
        opsValues.push(pOpsNum);
        opsColors.push('#ff7f0e');
      }
      if (Number.isFinite(h2hOpsNum)) {
        opsLabels.push('Head‑to‑head OPS');
        opsValues.push(h2hOpsNum);
        opsColors.push('#2ca02c');
      }
      const opsTrace = {
        x: opsLabels,
        y: opsValues,
        type: 'bar',
        marker: {color: opsColors}
      };
      const opsLayout = {
        title: 'OPS Comparison',
        yaxis: { title: 'OPS', range: [0, Math.max(...opsValues, 1.2)] },
        xaxis: { title: '' }
      };
      Plotly.newPlot('opsChart', [opsTrace], opsLayout, {responsive: true});

      // Chart 2: Park size and environmental effects (percentage)
      const envNum = parseFloat(envPercent);
      const effLabels = [];
      const effValues = [];
      const effColors = [];
      if (parkPercent !== null && !isNaN(parkPercent)) {
        effLabels.push('Park size effect');
        effValues.push(parkPercent);
        effColors.push('#8c564b');
      }
      if (!isNaN(envNum)) {
        effLabels.push('Environmental effect');
        effValues.push(envNum);
        effColors.push('#1f77b4');
      }
      const effTrace = {
        x: effLabels,
        y: effValues,
        type: 'bar',
        marker: {color: effColors}
      };
      const effLayout = {
        title: 'Park & Environmental Effects (\u0025 change)',
        yaxis: { title: '% change in fly‑ball distance' },
        xaxis: { title: '' }
      };
      Plotly.newPlot('parkEnvChart', [effTrace], effLayout, {responsive: true});
      // Chart 3: 3D scatter summarising factor contributions only (no events)
      const factorNames = [];
      const factorValues = [];
      const factorZ = [];
      // Career vs pitcher OPS diff
      if (Number.isFinite(bOpsNum) && Number.isFinite(pOpsNum)) {
        factorNames.push('Career OPS diff');
        factorValues.push(bOpsNum - pOpsNum);
        factorZ.push(0);
      }
      // Head‑to‑head vs career OPS diff
      if (Number.isFinite(h2hOpsNum) && Number.isFinite(bOpsNum)) {
        factorNames.push('H2H vs career OPS diff');
        factorValues.push(h2hOpsNum - bOpsNum);
        factorZ.push(0);
      }
      // Park effect (fraction)
      if (parkPercent !== null && !isNaN(parkPercent)) {
        factorNames.push('Park effect');
        factorValues.push((parkPercent) / 100);
        factorZ.push(0);
      }
      // Environment effect (fraction)
      if (!isNaN(envNum)) {
        factorNames.push('Env effect');
        factorValues.push(envNum / 100);
        factorZ.push(0);
      }
      const scatterTrace = {
        x: factorNames,
        y: factorValues,
        z: factorZ,
        mode: 'markers',
        type: 'scatter3d',
        marker: {
          size: 8,
          color: factorValues,
          colorscale: 'Portland',
          colorbar: { title: 'Impact' }
        },
        text: factorNames.map((f, i) => `${f}: ${factorValues[i].toFixed(3)}`),
        name: 'Factors'
      };
      const scatterLayout = {
        title: 'Advantage Factors (3D)',
        scene: {
          xaxis: { title: '' },
          yaxis: { title: 'Value' },
          zaxis: { title: '' },
          camera: { eye: { x: 1.2, y: 1.2, z: 1.2 } }
        },
        margin: { l: 0, r: 0, b: 0, t: 40 }
      };
      Plotly.newPlot('summary3D', [scatterTrace], scatterLayout, {responsive: true});

      // Chart 4: Predicted hit distribution bar chart
      const eventNames = ['Single', 'Double', 'Triple', 'Home Run'];
      const eventValues = [scaledDist.single, scaledDist.double, scaledDist.triple, scaledDist.hr];
      const eventTrace = {
        x: eventNames,
        y: eventValues.map(v => v * 100),
        type: 'bar',
        marker: { color: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'] }
      };
      const eventLayout = {
        title: 'Predicted Hit Distribution (%)',
        yaxis: { title: 'Probability (%)', range: [0, Math.max(...eventValues.map(v => v * 100), 1) ] },
        xaxis: { title: '' }
      };
      Plotly.newPlot('eventChart', [eventTrace], eventLayout, {responsive: true});
    }

    // Initialize page on load
    window.addEventListener('DOMContentLoaded', async () => {
      await fetchActivePlayers();
      populateSelect(document.getElementById('batterSelect'), batters);
      populateSelect(document.getElementById('pitcherSelect'), pitchers);
      populateStadiums();
      document.getElementById('compareBtn').addEventListener('click', compare);

      // When a new ballpark is selected, automatically fetch current weather and populate
      document.getElementById('stadiumSelect').addEventListener('change', (e) => {
        const stadiumName = e.target.value;
        fetchWeatherForStadium(stadiumName);
      });

      // Tab switching: show the matchup analysis or today's projections
      document.getElementById('matchTab').addEventListener('click', () => {
        document.getElementById('matchSection').style.display = 'block';
        document.getElementById('todaySection').style.display = 'none';
      });
      document.getElementById('todayTab').addEventListener('click', () => {
        document.getElementById('matchSection').style.display = 'none';
        document.getElementById('todaySection').style.display = 'block';
      });

      // Load projections for today when the button is clicked
      document.getElementById('loadProjectionsBtn').addEventListener('click', loadTodayProjections);
    });
  </script>

<!-- ===============================
     Weather-Driven Hit Odds (NEW)
     =============================== -->
<style>
  /* Minimal scoped styles to avoid collisions */
  .wdo-container { margin-top: 32px; }
  .wdo-banner { display:none; padding: 10px 12px; border-radius: 6px; margin-bottom: 12px; }
  .wdo-banner.warn { background: #fff7e6; border: 1px solid #ffd591; color: #ad6800; }
  .wdo-banner.info { background: #e6f4ff; border: 1px solid #91caff; color: #0958d9; }
  .wdo-controls { display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom: 12px; }
  .wdo-controls .control { display:flex; flex-direction:column; }
  .wdo-tab { border-top:1px solid #f0f0f0; padding-top: 12px; }
  .wdo-badge { display:inline-block; padding:0 6px; border-radius:10px; font-size:12px; margin-left:6px; }
  .wdo-badge.uncertain { background:#fff1f0; border:1px solid #ffa39e; color:#cf1322; }
  .wdo-table { width: 100%; border-collapse: collapse; }
  .wdo-table th, .wdo-table td { padding: 8px 10px; border-bottom: 1px solid #f0f0f0; font-size: 14px; white-space: nowrap; }
  .wdo-table th { text-align: left; }
  .wdo-sticky { position: sticky; top: 0; background: #fff; z-index: 1; }
</style>

<div id="weather-driven-hit-odds" class="wdo-container">
  <h2>Weather-Driven Hit Odds</h2>
  <p class="small text-muted">Confirmed starters only (batting order 1–9). Stadium-local “today”. Weather effects capped and renormalized. No guesses.</p>

  <div id="wdo-banner-await" class="wdo-banner info">Awaiting confirmed lineup.</div>
  <div id="wdo-banner-weather" class="wdo-banner warn">Weather unavailable for one or more games — effects set to neutral; rows flagged <span class="wdo-badge uncertain">uncertain weather</span>.</div>

  <div class="wdo-controls">
    <div class="control">
      <label for="wdo-team">Team</label>
      <select id="wdo-team"><option value="">All</option></select>
    </div>
    <div class="control">
      <label for="wdo-opp">Opp</label>
      <select id="wdo-opp"><option value="">All</option></select>
    </div>
    <div class="control">
      <label for="wdo-roof">Roof</label>
      <select id="wdo-roof">
        <option value="">All</option>
        <option value="open">Open</option>
        <option value="closed">Closed</option>
        <option value="unknown">Unknown</option>
      </select>
    </div>
    <div class="control">
      <label for="wdo-bats">Bats vs Throws</label>
      <select id="wdo-bats">
        <option value="">All</option>
        <option value="L">L vs R</option>
        <option value="R">R vs L</option>
        <option value="S">S vs Any</option>
      </select>
    </div>
    <div class="control">
      <label for="wdo-conf">Confidence ≥</label>
      <input type="range" id="wdo-conf" min="0" max="1" step="0.05" value="0.0">
      <div id="wdo-conf-val" class="small">0.00</div>
    </div>
    <div class="control">
      <label for="wdo-sort">Sort by</label>
      <select id="wdo-sort">
        <option value="hr">HR</option>
        <option value="single">1B</option>
        <option value="double">2B</option>
        <option value="triple">3B</option>
      </select>
    </div>
    <div class="control">
      <label>&nbsp;</label>
      <button id="wdo-refresh" class="btn btn-primary btn-sm">Load Today</button>
    </div>
  </div>

  <div class="wdo-tab">
    <table class="wdo-table" id="wdo-table">
      <thead class="wdo-sticky">
        <tr>
          <th>Player</th>
          <th>Team</th>
          <th>Opp</th>
          <th>Bat Ord</th>
          <th>Start Time (local)</th>
          <th>Stadium</th>
          <th>Roof</th>
          <th>Temp</th>
          <th>Wind</th>
          <th>1B</th>
          <th>2B</th>
          <th>3B</th>
          <th>HR</th>
          <th>Confidence</th>
          <th>Last Updated</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
(function(){
  const $team = document.getElementById('wdo-team');
  const $opp = document.getElementById('wdo-opp');
  const $roof = document.getElementById('wdo-roof');
  const $bats = document.getElementById('wdo-bats');
  const $conf = document.getElementById('wdo-conf');
  const $confVal = document.getElementById('wdo-conf-val');
  const $sort = document.getElementById('wdo-sort');
  const $btn = document.getElementById('wdo-refresh');
  const $tbody = document.querySelector('#wdo-table tbody');
  const $await = document.getElementById('wdo-banner-await');
  const $wban = document.getElementById('wdo-banner-weather');

  $conf.addEventListener('input', ()=>{ $confVal.textContent = Number($conf.value).toFixed(2); });

  function uniqueSorted(values){
    return Array.from(new Set(values)).filter(Boolean).sort();
  }

  function hydrateFilters(rows){
    const teams = uniqueSorted(rows.map(r => r.team));
    const opps = uniqueSorted(rows.map(r => r.opponent));
    $team.innerHTML = '<option value=\"\">All</option>' + teams.map(v=>`<option value=\"${v}\">${v}</option>`).join('');
    $opp.innerHTML = '<option value=\"\">All</option>' + opps.map(v=>`<option value=\"${v}\">${v}</option>`).join('');
  }

  function filterRows(rows){
    const t = $team.value, o = $opp.value, rf = $roof.value, bats = $bats.value, c = Number($conf.value);
    return rows.filter(r => (!t || r.team===t)
                         && (!o || r.opponent===o)
                         && (!rf || r.roof_status===rf)
                         && (!bats || r.bats===bats || (bats==='S' && r.bats==='S'))
                         && (r.confidence>=c));
  }

  function bannerState(rows){
    const anyUncertain = rows.some(r => r.uncertain_weather);
    $wban.style.display = anyUncertain ? 'block' : 'none';
    const hasRows = rows.length>0;
    $await.style.display = hasRows ? 'none' : 'block';
  }

  function render(rows){
    const sortKey = $sort.value;
    rows.sort((a,b)=> (b.probabilities[sortKey]||0)-(a.probabilities[sortKey]||0));
    $tbody.innerHTML = rows.map(r=>{
      const badge = r.uncertain_weather ? '<span class=\"wdo-badge uncertain\">uncertain weather</span>' : '';
      const wind = r.weather ? `${r.weather.wind_mph ?? 0} mph @ ${r.weather.wind_direction_deg ?? 0}°` : '—';
      const temp = r.weather ? `${r.weather.temp_f ?? '—'}` : '—';
      return `<tr>
        <td title=\"${r.model_notes}\">${r.player_name}${badge}</td>
        <td>${r.team}</td>
        <td>${r.opponent}</td>
        <td>${r.batting_order}</td>
        <td>${r.game_start_local}</td>
        <td>${r.stadium}</td>
        <td>${r.roof_status}</td>
        <td>${temp}</td>
        <td>${wind}</td>
        <td>${(r.probabilities.single ?? 0).toFixed(3)}</td>
        <td>${(r.probabilities.double ?? 0).toFixed(3)}</td>
        <td>${(r.probabilities.triple ?? 0).toFixed(3)}</td>
        <td>${(r.probabilities.hr ?? 0).toFixed(3)}</td>
        <td>${(r.confidence ?? 0).toFixed(2)}</td>
        <td>${r.last_updated}</td>
      </tr>`;
    }).join('');
  }

  async function load(){
    $tbody.innerHTML = '';
    $await.style.display = 'none';
    $wban.style.display = 'none';

    try {
      const res = await fetch('/api/weather_hit_odds');
      const rows = await res.json();
      hydrateFilters(rows);
      const f = filterRows(rows);
      bannerState(f);
      render(f);
    } catch (e){
      console.error(e);
      $await.textContent = 'Failed to load data.';
      $await.style.display = 'block';
    }
  }

  $btn.addEventListener('click', load);
})();
</script>


<!-- ===============================
     Weather-Driven Hit Odds (NEW)
     =============================== -->
<style>
  .wdo-container { margin-top: 32px; }
  .wdo-banner { display:none; padding: 10px 12px; border-radius: 6px; margin-bottom: 12px; }
  .wdo-banner.warn { background: #fff7e6; border: 1px solid #ffd591; color: #ad6800; }
  .wdo-banner.info { background: #e6f4ff; border: 1px solid #91caff; color: #0958d9; }
  .wdo-controls { display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom: 12px; }
  .wdo-controls .control { display:flex; flex-direction:column; }
  .wdo-tab { border-top:1px solid #f0f0f0; padding-top: 12px; }
  .wdo-badge { display:inline-block; padding:0 6px; border-radius:10px; font-size:12px; margin-left:6px; }
  .wdo-badge.uncertain { background:#fff1f0; border:1px solid #ffa39e; color:#cf1322; }
  .wdo-table { width: 100%; border-collapse: collapse; }
  .wdo-table th, .wdo-table td { padding: 8px 10px; border-bottom: 1px solid #f0f0f0; font-size: 14px; white-space: nowrap; }
  .wdo-table th { text-align: left; }
  .wdo-sticky { position: sticky; top: 0; background: #fff; z-index: 1; }
</style>

<div id="weather-driven-hit-odds" class="wdo-container">
  <h2>Weather-Driven Hit Odds</h2>
  <p class="small text-muted">Confirmed starters only (batting order 1–9). Stadium-local “today”. Weather effects capped and renormalized. No guesses.</p>

  <div id="wdo-banner-await" class="wdo-banner info">Awaiting confirmed lineup.</div>
  <div id="wdo-banner-weather" class="wdo-banner warn">Weather unavailable for one or more games — effects set to neutral; rows flagged <span class="wdo-badge uncertain">uncertain weather</span>.</div>

  <div class="wdo-controls">
    <div class="control">
      <label for="wdo-team">Team</label>
      <select id="wdo-team"><option value="">All</option></select>
    </div>
    <div class="control">
      <label for="wdo-opp">Opp</label>
      <select id="wdo-opp"><option value="">All</option></select>
    </div>
    <div class="control">
      <label for="wdo-roof">Roof</label>
      <select id="wdo-roof">
        <option value="">All</option>
        <option value="open">Open</option>
        <option value="closed">Closed</option>
        <option value="unknown">Unknown</option>
      </select>
    </div>
    <div class="control">
      <label for="wdo-bats">Bats vs Throws</label>
      <select id="wdo-bats">
        <option value="">All</option>
        <option value="L">L vs R</option>
        <option value="R">R vs L</option>
        <option value="S">S vs Any</option>
      </select>
    </div>
    <div class="control">
      <label for="wdo-conf">Confidence ≥</label>
      <input type="range" id="wdo-conf" min="0" max="1" step="0.05" value="0.0">
      <div id="wdo-conf-val" class="small">0.00</div>
    </div>
    <div class="control">
      <label for="wdo-sort">Sort by</label>
      <select id="wdo-sort">
        <option value="hr">HR</option>
        <option value="single">1B</option>
        <option value="double">2B</option>
        <option value="triple">3B</option>
      </select>
    </div>
    <div class="control">
      <label>&nbsp;</label>
      <button id="wdo-refresh" class="btn btn-primary btn-sm">Load Today</button>
    </div>
  </div>

  <div class="wdo-tab">
    <table class="wdo-table" id="wdo-table">
      <thead class="wdo-sticky">
        <tr>
          <th>Player</th>
          <th>Team</th>
          <th>Opp</th>
          <th>Bat Ord</th>
          <th>Start Time (local)</th>
          <th>Stadium</th>
          <th>Roof</th>
          <th>Temp</th>
          <th>Wind</th>
          <th>1B</th>
          <th>2B</th>
          <th>3B</th>
          <th>HR</th>
          <th>Confidence</th>
          <th>Last Updated</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
(function(){
  const $team = document.getElementById('wdo-team');
  const $opp = document.getElementById('wdo-opp');
  const $roof = document.getElementById('wdo-roof');
  const $bats = document.getElementById('wdo-bats');
  const $conf = document.getElementById('wdo-conf');
  const $confVal = document.getElementById('wdo-conf-val');
  const $sort = document.getElementById('wdo-sort');
  const $btn = document.getElementById('wdo-refresh');
  const $tbody = document.querySelector('#wdo-table tbody');
  const $await = document.getElementById('wdo-banner-await');
  const $wban = document.getElementById('wdo-banner-weather');

  $conf.addEventListener('input', ()=>{ $confVal.textContent = Number($conf.value).toFixed(2); });

  function uniqueSorted(values){ return Array.from(new Set(values)).filter(Boolean).sort(); }

  function hydrateFilters(rows){
    const teams = uniqueSorted(rows.map(r => r.team));
    const opps = uniqueSorted(rows.map(r => r.opponent));
    $team.innerHTML = '<option value=\"\">All</option>' + teams.map(v=>`<option value=\"${v}\">${v}</option>`).join('');
    $opp.innerHTML = '<option value=\"\">All</option>' + opps.map(v=>`<option value=\"${v}\">${v}</option>`).join('');
  }

  function filterRows(rows){
    const t = $team.value, o = $opp.value, rf = $roof.value, bats = $bats.value, c = Number($conf.value);
    return rows.filter(r => (!t || r.team===t)
                         && (!o || r.opponent===o)
                         && (!rf || r.roof_status===rf)
                         && (!bats || r.bats===bats || (bats==='S' && r.bats==='S'))
                         && (r.confidence>=c));
  }

  function bannerState(rows){
    const anyUncertain = rows.some(r => r.uncertain_weather);
    $wban.style.display = anyUncertain ? 'block' : 'none';
    const hasRows = rows.length>0;
    $await.style.display = hasRows ? 'none' : 'block';
  }

  function render(rows){
    const sortKey = $sort.value;
    rows.sort((a,b)=> (b.probabilities[sortKey]||0)-(a.probabilities[sortKey]||0));
    $tbody.innerHTML = rows.map(r=>{
      const badge = r.uncertain_weather ? '<span class=\"wdo-badge uncertain\">uncertain weather</span>' : '';
      const wind = r.weather ? `${r.weather.wind_mph ?? 0} mph @ ${r.weather.wind_direction_deg ?? 0}°` : '—';
      const temp = r.weather ? `${r.weather.temp_f ?? '—'}` : '—';
      return `<tr>
        <td title=\"${r.model_notes}\">${r.player_name}${badge}</td>
        <td>${r.team}</td>
        <td>${r.opponent}</td>
        <td>${r.batting_order}</td>
        <td>${r.game_start_local}</td>
        <td>${r.stadium}</td>
        <td>${r.roof_status}</td>
        <td>${temp}</td>
        <td>${wind}</td>
        <td>${(r.probabilities.single ?? 0).toFixed(3)}</td>
        <td>${(r.probabilities.double ?? 0).toFixed(3)}</td>
        <td>${(r.probabilities.triple ?? 0).toFixed(3)}</td>
        <td>${(r.probabilities.hr ?? 0).toFixed(3)}</td>
        <td>${(r.confidence ?? 0).toFixed(2)}</td>
        <td>${r.last_updated}</td>
      </tr>`;
    }).join('');
  }

  async function load(){
    $tbody.innerHTML = '';
    $await.style.display = 'none';
    $wban.style.display = 'none';
    try {
      const res = await fetch('/api/weather_hit_odds');
      const rows = await res.json();
      hydrateFilters(rows);
      const f = filterRows(rows);
      bannerState(f);
      render(f);
    } catch (e){
      console.error(e);
      $await.textContent = 'Failed to load data.';
      $await.style.display = 'block';
    }
  }

  $btn.addEventListener('click', load);
})();
</script>

</body>
</html>